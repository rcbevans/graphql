[[auth-authorization-where]]
= Where

Use the `where` argument on types to conceptually append predicates to the Cypher `WHERE` clause. Given the current user ID is "123" and the following schema:

[source, graphql, indent=0]
----
type User {
    id: ID
    name: String
}

extend type User @auth(rules: [{ where: { id: "$jwt.id" } }])
----

Then the user executes a GraphQL query for all users:

[source, graphql, indent=0]
----
query {
    users {
        id
        name
    }
}
----

Behind the scenes the userâ€™s ID is conceptually added to the query:

[source, graphql, indent=0]
----
query {
    users(where: { id: "123" }){
        id
        name
    }
}
----

Where is used on the following operations;

- `READ`
- `UPDATE`
- `CONNECT`
- `DISCONNECT`
- `DELETE`

== `where` on relationships

You can use a `where` clause with a relationship on a type to filter the results that will be returned to a caller.

In the following schema, the `where` clause allows the caller to see the `Post` nodes where all of the moderators have an id matching the provided JWT subject.

[source, graphql, indent=0]
----
type User {
    id: ID
    name: String
}

type Post {
    content: String
    moderators: [User] @relationship(type: "MODERATES_POST", direction: IN)
}

extend type Post @auth(rules: [
    { operations: [READ], where: { moderators: { id: "$jwt.sub" } } }
])
----

== Field modifiers

You can combine fields in `where` clauses with supported field modifiers to customize the filtering that is performed, see the xref::auth/authorization/modifiers.adoc[Modifiers] documentation.

== Combining `where` with `roles`

The `where` argument can be combined with `roles` within auth rules to support rule based filtering of results.

Revising the early example schema, if we update the auth rules to instead provide two sets of rules for two different roles, we can specify that jwts with the `user` role can only see their own `User` node, as before, but now, those with the `admin` role can see all users:

extend type User @auth(rules: [
    { 
        roles: ["user"]
        where: { id: "$jwt.id" } 
    }
    {
        roles: ["admin"]
    }
])
----

For those with an admin role, there is a conceptual `where: "*"` rule which is applied, allowing admins to see all `User` nodes.

These rules can alternatively be expressed using an `OR` within the top parent of a single auth rule, for example:

[source, graphql, indent=0]
----
type User {
    id: ID
    name: String
}

extend type User @auth(rules: [
    {
        OR: [
            {
                roles: ["user"]
                where: { id: "$jwt.id" } 
            },
            {
                roles: ["admin"]
            }
        ]
    }
])
----

Both ways of expressing the rules are valid, and will return the same results.
